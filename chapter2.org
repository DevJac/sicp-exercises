#+STARTUP: indent
* [29/33] Chapter2
** DONE Exercise 2.1
#+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cond ((negative? d) (cons (* -1 (/ n g)) (* -1 (/ d g))))
            (else (cons (/ n g) (/ d g))))))
#+END_SRC
** DONE Exercise 2.3
The exercises asks us to create a rectangle abstraction and procedures to compute the perimeter and area.

#+BEGIN_SRC scheme
  (define (make-rect w h)
    (cons w h))
  (define (rect-width r) (car r))
  (define (rect-height r) (cdr r))
  (define (rect-perimeter r)
    (* 2 (+ (rect-width r) (rect-height r))))
  (define (rect-area r)
    (* (rect-width r) (rect-height r)))
#+END_SRC

The exercise then asks us to change the representation of our rectangle without having to change the perimeter or area procedures.

#+BEGIN_SRC scheme
  (define (make-point x y)
    (cons x y))
  (define (make-rect center w h)
    (cons center (cons w h)))
  (define (rect-width r) (car (cdr r)))
  (define (rect-height r) (cdr (cdr r)))
  (define (rect-perimeter r)
    (* 2 (+ (rect-width r) (rect-height r))))
  (define (rect-area r)
    (* (rect-width r) (rect-height r)))
#+END_SRC

I changed the rectangle so that it includes the center point, and then had to adjust ~rect-width~ and ~rect-height~, but not the perimeter or area procedures. The perimeter and area procedures continued to work without modification.
** DONE Exercise 2.4
The exercise asks us to explain the following implementation of pairs.

#+BEGIN_SRC scheme
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
#+END_SRC

Let's do the substitutions.

#+BEGIN_SRC scheme
  (cons x y)
  (lambda (m) (m x y))

  (car (lambda (m) (m x y)))
  ((lambda (m) (m x y)) (lambda (p q) p))
  ((lambda (p q) p) x y)
  x
#+END_SRC

~cons~ produces an "apply-er" and ~car~ is a "getter" which returns the first given argument. ~car~ takes the "apply-er" which applies the "getter" and you end up with the first element of the pair.

The full implementation of a pair, including ~cdr~ follows.

#+BEGIN_SRC scheme
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC
** DONE Exercise 2.5
#+BEGIN_SRC scheme
  (define (divisible-by? n d)
    (= 0 (remainder n d)))
  (define (factor-count n f)
    (cond ((divisible-by? n f) (+ 1 (factor-count (/ n f) f)))
          (else 0)))
  (define (cons a b)
    (* (expt 2 a) (expt 3 b)))
  (define (car n)
    (factor-count n 2))
  (define (cdr n)
    (factor-count n 3))
#+END_SRC
** DONE Exercise 2.7
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define lower-bound car)
  (define upper-bound cdr)
#+END_SRC
** DONE Exercise 2.8
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define lower-bound car)
  (define upper-bound cdr)
  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))
  (define (sub-interval x y)
    (add-interval x (mul-interval y (make-interval -1 -1))))
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))
#+END_SRC
** DONE Exercise 2.12
#+BEGIN_SRC scheme
  (define (make-center-percent c p)
    (let ((range (* c p)))
      (make-interval (- c range) (+ c range))))
  (define (average a b)
    (/ (+ a b) 2))
  (define (percent i)
    (let ((center (average (lower-bound i) (upper-bound i))))
      (let ((range (- (upper-bound i) center)))
        (/ range center))))
#+END_SRC
** DONE Exercise 2.14
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define lower-bound car)
  (define upper-bound cdr)
  (define (make-center-percent c p)
    (let ((range (* c p)))
      (make-interval (- c range) (+ c range))))
  (define (average a b)
    (/ (+ a b) 2))
  (define (center i)
    (average (lower-bound i) (upper-bound i)))
  (define (percent i)
    (let ((range (- (upper-bound i) (center i))))
      (/ range (center i))))
  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))
  (define (div-interval x y)
    (mul-interval
     x
     (make-interval (/ 1.0 (upper-bound y))
                    (/ 1.0 (lower-bound y)))))
  (define a (make-center-percent 100 0.01))
  (define b (make-center-percent 100 0.01))
  (div-interval a a)
  (div-interval a b)
#+END_SRC

The problem here is that =A/A= should be exactly =1=, and =A/B= should have some uncertainty, but both calculations have some uncertainty.

You could try every permutation of lower and upper bound across the variables. This would ensure a "high A" is divided by another "high A" and thus would be exactly 1, while =A/B= had some uncertainty. You might also need to check a number of points in between to handle the variables being used in non-linear functions.
** DONE Exercise 2.15
Yes. ~par2~ is better because the uncertainty of each variable is only introduced once. Using a variable multiple times introduces that variables uncertainty to the calculation multiple times. ~par2~ uses each variable only once.

#+BEGIN_SRC scheme
  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
                  (add-interval r1 r2)))
  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval
       one (add-interval (div-interval one r1)
                         (div-interval one r2)))))

  (define r1 (make-center-percent 100 0.05))
  (define r2 (make-center-percent 100 0.05))
  (par1 r1 r2)
  (par2 r1 r2)
#+END_SRC

The above code produces the following output.

#+BEGIN_SRC scheme
  (42.97619047619048 . 58.026315789473685)
  (47.5 . 52.49999999999999)
#+END_SRC

This demonstrates that ~par2~ has less uncertainty, while still being a valid equation.
** DONE Exercise 2.17
#+BEGIN_SRC scheme
  (define (last-pair xs)
    (cond ((null? (cdr xs)) xs)
          (else (last-pair (cdr xs)))))
#+END_SRC
** DONE Exercise 2.18
#+BEGIN_SRC scheme
  (define (reverse xs)
    (define (iter xs reversed)
      (if (null? xs) reversed (iter (cdr xs) (cons (car xs) reversed))))
    (iter xs nil))
#+END_SRC
** DONE Exercise 2.20
#+BEGIN_SRC scheme
  (define (same-parity first . rest)
    (define (iter rest result)
      (cond ((null? rest) result)
            ((and (even? first) (even? (car rest))) (iter (cdr rest) (cons (car rest) result)))
            ((and (odd? first) (odd? (car rest))) (iter (cdr rest) (cons (car rest) result)))
            (else (iter (cdr rest) result))))
    (reverse (iter rest (list first))))
#+END_SRC
** DONE Exercise 2.21
#+BEGIN_SRC scheme
  (define (square n) (* n n))
  (define (square-list-0 items)
    (if (null? items)
        nil
        (cons (square (car items)) (square-list (cdr items)))))
  (define (square-list items)
    (map square items))
#+END_SRC
** DONE Exercise 2.23
#+BEGIN_SRC scheme
  (define (for-each f xs)
    (f (car xs))
    (if (pair? (cdr xs))
        (for-each f (cdr xs))))
#+END_SRC
** DONE Exercise 2.25
#+BEGIN_SRC scheme
  (cadr (caddr (list 1 3 (list 5 7) 9)))
  (car (car (list (list 7))))
  (define x (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
  (cadr (cadr (cadr (cadr (cadr (cadr x))))))
#+END_SRC
** DONE Exercise 2.31
#+BEGIN_SRC scheme
  (define (tree-map f tree)
    (define (g x)
      (cond ((pair? x) (tree-map f x))
            (else (f x))))
    (map g tree))
#+END_SRC
** DONE Exercise 2.33
#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))
  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) nil sequence))
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))
  (define (length sequence)
    (accumulate (lambda (_ len) (inc len)) 0 sequence))
#+END_SRC
** DONE Exercise 2.38
#+BEGIN_SRC scheme
  (define (fold-right op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))
  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
          result
          (iter (op result (car rest))
                (cdr rest))))
    (iter initial sequence))
  (fold-right / 1 (list 1 2 3))
  (fold-left / 1 (list 1 2 3))
  (fold-right list nil (list 1 2 3))
  (fold-left list nil (list 1 2 3))
#+END_SRC

~op~ would have to be commutative for both ~fold-right~ and ~fold-left~ to give the same result.

~fold-left~ folds from left to right, it applies ~op~ to the items on the left first. ~fold-right~ is opposite. I always forget which directions the folds go in. For example, "fold left" could mean the fold is "going left" or that it is starting from left and "going right". ~fold-left~ goes right, it folds from left to right. ~fold-left~ seems more natural, since we are accustomed to reading lists from left to right.
** DONE Exercise 2.40
#+BEGIN_SRC scheme
  (define (enumerate-interval low high)
    (if (> low high)
        nil
        (cons low (enumerate-interval (+ low 1) high))))
  (define (unique-pairs n)
    (flatmap
     (lambda (i) (map (lambda (j) (cons i j)) (enumerate-interval 1 (dec i))))
     (enumerate-interval 2 n)))
  (define (prime-sum? pair)
    (prime? (+ (car pair) (cdr pair))))
  (define (prime-sum-pairs n)
    (filter prime-sum? (unique-pairs n)))
  (prime-sum-pairs 5)
#+END_SRC
** DONE Exercise 2.53
I evaluated each of the expressions mentally and then checked my answers with the REPL.

#+BEGIN_SRC scheme
  (a b c)
  ((george))
  ((y1 y2))
  (y1 y2)
  #f
  #f
  (red shoes blue socks)
#+END_SRC

#+BEGIN_SRC scheme
  (list 'a 'b 'c)
  (list (list 'george))
  (cdr '((x1 x2) (y1 y2)))
  (cadr '((x1 x2) (y1 y2)))
  (pair? (car '(a short list)))
  (memq 'red '((red shoes) (blue socks)))
  (memq 'red '(red shoes blue socks))
#+END_SRC
** DONE Exercise 2.54
#+BEGIN_SRC scheme
  (define (equal? a b)
    (cond ((or (null? a) (null? b)) (if (and (null? a) (null? b)) true false))
          ((and (pair? (car a)) (pair? (car b))) (equal? (car a) (car b)))
          (else (and (eq? (car a) (car b)) (equal? (cdr a) (cdr b))))))
  (equal? (list 1 2 3) (list 1 2 3))
  (equal? (list 1 2) (list 1 3))
  (equal? (list 1 2 (list 3 4) 5 6) (list 1 2 (list 3 4) 5 6))
  (equal? (list 1 2 (list 3 0) 5 6) (list 1 2 (list 3 4) 5 6))
  (equal? (list 1 0 (list 3 0) 5 6) (list 1 2 (list 3 4) 5 6))
  (equal? (list 1 2 (list 3 0) 5 6) (list 1 2 (list 3 4) 5 0))
#+END_SRC
** DONE Exercise 2.55
~(car ''abracadabra)~ is ~(car (quote (quote abracadabra)))~, which ends up taking the ~car~ of the 2 element list ~(quote abracadabra)~, which is ~quote~.
** DONE Exercise 2.59
#+BEGIN_SRC scheme
  (define (element-of-set? x set)
    (cond ((null? set) false)
          ((equal? x (car set)) true)
          (else (element-of-set? x (cdr set)))))
  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))
  (define (union-set set1 set2)
    (accumulate adjoin-set set1 set2))
  (union-set (list 1 2 3) (list 1 2 3))
  (union-set (list 1 2) (list 2 3))
  (union-set (list 1 2 3) (list))
  (union-set (list 1) (list 2 3))
#+END_SRC
** DONE Exercise 2.62
#+BEGIN_SRC scheme
  (define (union-set set1 set2)
    (cond ((and (null? set1) (null? set2)) nil)
          ((null? set1) (cons (car set2) (union-set set1 (cdr set2))))
          ((null? set2) (cons (car set1) (union-set (cdr set1) set2)))
          ((eq? (car set1) (car set2)) (cons (car set1) (union-set (cdr set1) (cdr set2))))
          ((< (car set1) (car set2)) (cons (car set1) (union-set (cdr set1) set2)))
          (else (cons (car set2) (union-set set1 (cdr set2))))))
  (union-set (list 1 2 3) (list 1 2 3))
  (union-set (list 1 2) (list 2 3))
  (union-set (list 1 2 3) (list))
  (union-set (list 1) (list 2 3))
  (union-set (list 1 3 4 6 9 10) (list 1 2 3 5 7 8 9))
#+END_SRC
** DONE Exercise 2.75
#+BEGIN_SRC scheme
  (define (make-from-real-imag x y)
    (define (dispatch op)
      (cond ((eq? op 'real-part) x)
            ((eq? op 'imag-part) y)
            ((eq? op 'magnitude) (sqrt (+ (square x) (square y))))
            ((eq? op 'angle) (atan y x))
            (else (error "Unknown op: MAKE-FROM-REAL-IMAG" op))))
    dispatch)
  (define (make-from-mag-ang r a)
    (define (dispatch op)
      (cond ((eq? op 'real-part) (* r (cos a)))
            ((eq? op 'imag-part) (* r (sin a)))
            ((eq? op 'magnitude) r)
            ((eq? op 'angle) a)))
    dispatch)
  (define a (make-from-real-imag 3 5))
  (define b (make-from-mag-ang (a 'magnitude) (a 'angle)))
  (a 'real-part)
  (b 'real-part)
  (a 'imag-part)
  (b 'imag-part)
  (a 'magnitude)
  (b 'magnitude)
  (a 'angle)
  (b 'angle)
#+END_SRC
** DONE Exercise 2.76
*** generic operations with explicit dispatch
Tag the data with its "type", then hard-code every "operation" to handle every type. (An "operation" is a procedure intended to be used with the relevant data.)

When a new type is added, all existing operations must be updated.
When a new operation is added, it can be added in isolation, but the new operation must be aware of all existing types.
*** data directed
Maintain a table of types and operations, such that we can lookup what specific procedure implements an operation for a specific type.

When a new type is added, new entries to the types/operations table must be made, but the rest of our system can remain unchanged.
When a new operation is added, it must be implemented for all existing types, and then the types/operations table must be updated.
*** message passing
Each type maintains its own operations internally. Types expose a common interface so that higher level procedures can call the internal operations of the type without ever knowing exactly what type it is.

When a new type is added, it must implement the expected operations internally and expose them in the expected way.
When a new operation is added, all existing types must be updated to add the new operation to their other internal operations.
*** thoughts
The amount of work needed with any system is roughly =number-of-types * number-of-operations=.

The first system with generic operations using explicit dispatch seems more ad hoc; you have more control but that can be a bad thing because the dispatch for each operation may look completely different.

Besides the downsides of generic operations with explicit dispatch, I don't think either system is necessarily better for adding new types or operations.
** DONE Exercise 2.78
#+BEGIN_SRC scheme
  (define (attach-tag type-tag contents)
    (cond ((eq? type-tag 'scheme-number) contents)
          (else (cons type-tag contents))))
  (define (type-tag datum)
    (cond ((number? datum) 'scheme-number)
          (else (if (pair? datum)
                    (car datum)
                    (error "Bad tagged datum: TYPE-TAG" datum)))))
  (define (contents datum)
    (cond ((number? datum) datum)
          (else (if (pair? datum)
                    (cdr datum)
                    (error "Bad tagged datum: CONTENTS" datum)))))
#+END_SRC
** DONE Exercise 2.79
#+BEGIN_SRC scheme
  (define (equ? x y) (apply-generic 'equ? x y))
  (define (=zero? x) (apply-generic '=zero? x))
  (define (install-scheme-number-package)
    ...
    (put 'equ? '(scheme-number scheme-number)
         (lambda (x y) (= x y)))
    (put '=zero? 'scheme-number
         (lambda (x) (= x 0)))
    'done)
  (define (install-rational-package)
    ...
    (put 'equ? '(rational rational)
         (lambda (x y) (and (= (numer x) (numer y))
                            (= (denom x) (denom y)))))
    (put '=zero? 'rational
         (lambda (x) (= 0 (numer x))))
    'done)
  (define (install-complex-package)
    ...
    (put 'equ? '(complex complex)
         (lambda (x y) (and (= (real-part x) (real-part y))
                            (= (imag-part x) (imag-part y)))))
    (put '=zero? 'complex
         (lambda (x) (and (= 0 (real-part x)) (= 0 (imag-part x)))))
    'done)
#+END_SRC
** DONE Exercise 2.80
See Exercise 2.79.
** TODO Exercise 2.83
** TODO Exercise 2.84
** TODO Exercise 2.85
** TODO Exercise 2.88
