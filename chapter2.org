#+STARTUP: indent
* [19/19] Chapter2
** DONE Exercise 2.1
#+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cond ((negative? d) (cons (* -1 (/ n g)) (* -1 (/ d g))))
            (else (cons (/ n g) (/ d g))))))
#+END_SRC
** DONE Exercise 2.3
The exercises asks us to create a rectangle abstraction and procedures to compute the perimeter and area.

#+BEGIN_SRC scheme
  (define (make-rect w h)
    (cons w h))
  (define (rect-width r) (car r))
  (define (rect-height r) (cdr r))
  (define (rect-perimeter r)
    (* 2 (+ (rect-width r) (rect-height r))))
  (define (rect-area r)
    (* (rect-width r) (rect-height r)))
#+END_SRC

The exercise then asks us to change the representation of our rectangle without having to change the perimeter or area procedures.

#+BEGIN_SRC scheme
  (define (make-point x y)
    (cons x y))
  (define (make-rect center w h)
    (cons center (cons w h)))
  (define (rect-width r) (car (cdr r)))
  (define (rect-height r) (cdr (cdr r)))
  (define (rect-perimeter r)
    (* 2 (+ (rect-width r) (rect-height r))))
  (define (rect-area r)
    (* (rect-width r) (rect-height r)))
#+END_SRC

I changed the rectangle so that it includes the center point, and then had to adjust ~rect-width~ and ~rect-height~, but not the perimeter or area procedures. The perimeter and area procedures continued to work without modification.
** DONE Exercise 2.4
The exercise asks us to explain the following implementation of pairs.

#+BEGIN_SRC scheme
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
#+END_SRC

Let's do the substitutions.

#+BEGIN_SRC scheme
  (cons x y)
  (lambda (m) (m x y))

  (car (lambda (m) (m x y)))
  ((lambda (m) (m x y)) (lambda (p q) p))
  ((lambda (p q) p) x y)
  x
#+END_SRC

~cons~ produces an "apply-er" and ~car~ is a "getter" which returns the first given argument. ~car~ takes the "apply-er" which applies the "getter" and you end up with the first element of the pair.

The full implementation of a pair, including ~cdr~ follows.

#+BEGIN_SRC scheme
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC
** DONE Exercise 2.5
#+BEGIN_SRC scheme
  (define (divisible-by? n d)
    (= 0 (remainder n d)))
  (define (factor-count n f)
    (cond ((divisible-by? n f) (+ 1 (factor-count (/ n f) f)))
          (else 0)))
  (define (cons a b)
    (* (expt 2 a) (expt 3 b)))
  (define (car n)
    (factor-count n 2))
  (define (cdr n)
    (factor-count n 3))
#+END_SRC
** DONE Exercise 2.7
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define lower-bound car)
  (define upper-bound cdr)
#+END_SRC
** DONE Exercise 2.8
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define lower-bound car)
  (define upper-bound cdr)
  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))
  (define (sub-interval x y)
    (add-interval x (mul-interval y (make-interval -1 -1))))
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))
#+END_SRC
** DONE Exercise 2.12
#+BEGIN_SRC scheme
  (define (make-center-percent c p)
    (let ((range (* c p)))
      (make-interval (- c range) (+ c range))))
  (define (average a b)
    (/ (+ a b) 2))
  (define (percent i)
    (let ((center (average (lower-bound i) (upper-bound i))))
      (let ((range (- (upper-bound i) center)))
        (/ range center))))
#+END_SRC
** DONE Exercise 2.14
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define lower-bound car)
  (define upper-bound cdr)
  (define (make-center-percent c p)
    (let ((range (* c p)))
      (make-interval (- c range) (+ c range))))
  (define (average a b)
    (/ (+ a b) 2))
  (define (center i)
    (average (lower-bound i) (upper-bound i)))
  (define (percent i)
    (let ((range (- (upper-bound i) (center i))))
      (/ range (center i))))
  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (lower-bound y)))
          (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))
  (define (div-interval x y)
    (mul-interval
     x
     (make-interval (/ 1.0 (upper-bound y))
                    (/ 1.0 (lower-bound y)))))
  (define a (make-center-percent 100 0.01))
  (define b (make-center-percent 100 0.01))
  (div-interval a a)
  (div-interval a b)
#+END_SRC

The problem here is that =A/A= should be exactly =1=, and =A/B= should have some uncertainty, but both calculations have some uncertainty.

You could try every permutation of lower and upper bound across the variables. This would ensure a "high A" is divided by another "high A" and thus would be exactly 1, while =A/B= had some uncertainty. You might also need to check a number of points in between to handle the variables being used in non-linear functions.
** DONE Exercise 2.15
Yes. ~par2~ is better because the uncertainty of each variable is only introduced once. Using a variable multiple times introduces that variables uncertainty to the calculation multiple times. ~par2~ uses each variable only once.

#+BEGIN_SRC scheme
  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
                  (add-interval r1 r2)))
  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval
       one (add-interval (div-interval one r1)
                         (div-interval one r2)))))

  (define r1 (make-center-percent 100 0.05))
  (define r2 (make-center-percent 100 0.05))
  (par1 r1 r2)
  (par2 r1 r2)
#+END_SRC

The above code produces the following output.

#+BEGIN_SRC scheme
  (42.97619047619048 . 58.026315789473685)
  (47.5 . 52.49999999999999)
#+END_SRC

This demonstrates that ~par2~ has less uncertainty, while still being a valid equation.
** DONE Exercise 2.17
#+BEGIN_SRC scheme
  (define (last-pair xs)
    (cond ((null? (cdr xs)) xs)
          (else (last-pair (cdr xs)))))
#+END_SRC
** DONE Exercise 2.18
#+BEGIN_SRC scheme
  (define (reverse xs)
    (define (iter xs reversed)
      (if (null? xs) reversed (iter (cdr xs) (cons (car xs) reversed))))
    (iter xs nil))
#+END_SRC
** DONE Exercise 2.20
#+BEGIN_SRC scheme
  (define (same-parity first . rest)
    (define (iter rest result)
      (cond ((null? rest) result)
            ((and (even? first) (even? (car rest))) (iter (cdr rest) (cons (car rest) result)))
            ((and (odd? first) (odd? (car rest))) (iter (cdr rest) (cons (car rest) result)))
            (else (iter (cdr rest) result))))
    (reverse (iter rest (list first))))
#+END_SRC
** DONE Exercise 2.21
#+BEGIN_SRC scheme
  (define (square n) (* n n))
  (define (square-list-0 items)
    (if (null? items)
        nil
        (cons (square (car items)) (square-list (cdr items)))))
  (define (square-list items)
    (map square items))
#+END_SRC
** DONE Exercise 2.23
#+BEGIN_SRC scheme
  (define (for-each f xs)
    (f (car xs))
    (if (pair? (cdr xs))
        (for-each f (cdr xs))))
#+END_SRC
** DONE Exercise 2.25
#+BEGIN_SRC scheme
  (cadr (caddr (list 1 3 (list 5 7) 9)))
  (car (car (list (list 7))))
  (define x (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
  (cadr (cadr (cadr (cadr (cadr (cadr x))))))
#+END_SRC
** DONE Exercise 2.31
#+BEGIN_SRC scheme
  (define (tree-map f tree)
    (define (g x)
      (cond ((pair? x) (tree-map f x))
            (else (f x))))
    (map g tree))
#+END_SRC
** DONE Exercise 2.33
#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))
  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) nil sequence))
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))
  (define (length sequence)
    (accumulate (lambda (_ len) (inc len)) 0 sequence))
#+END_SRC
** DONE Exercise 2.38
#+BEGIN_SRC scheme
  (define (fold-right op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))
  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
          result
          (iter (op result (car rest))
                (cdr rest))))
    (iter initial sequence))
  (fold-right / 1 (list 1 2 3))
  (fold-left / 1 (list 1 2 3))
  (fold-right list nil (list 1 2 3))
  (fold-left list nil (list 1 2 3))
#+END_SRC

~op~ would have to be commutative for both ~fold-right~ and ~fold-left~ to give the same result.

~fold-left~ folds from left to right, it applies ~op~ to the items on the left first. ~fold-right~ is opposite. I always forget which directions the folds go in. For example, "fold left" could mean the fold is "going left" or that it is starting from left and "going right". ~fold-left~ goes right, it folds from left to right. ~fold-left~ seems more natural, since we are accustomed to reading lists from left to right.
** DONE Exercise 2.40
#+BEGIN_SRC scheme
  (define (enumerate-interval low high)
    (if (> low high)
        nil
        (cons low (enumerate-interval (+ low 1) high))))
  (define (unique-pairs n)
    (flatmap
     (lambda (i) (map (lambda (j) (cons i j)) (enumerate-interval 1 (dec i))))
     (enumerate-interval 2 n)))
  (define (prime-sum? pair)
    (prime? (+ (car pair) (cdr pair))))
  (define (prime-sum-pairs n)
    (filter prime-sum? (unique-pairs n)))
  (prime-sum-pairs 5)
#+END_SRC
