* SICP [35/356] [9%]
:PROPERTIES:
:COOKIE_DATA: recursive
:END:
** Chapter 1 [35/46] [76%]
*** DONE Exercise 1.1
CLOSED: [2017-12-17 Sun 22:11]
The expected outputs are:

#+BEGIN_EXAMPLE
10
12
8
3
6
19
#f
4
16
6
16
#+END_EXAMPLE

I performed these calculations mentally, and they matched the results I got from the interpreter.
*** DONE Exercise 1.2
CLOSED: [2017-12-17 Sun 22:16]
#+BEGIN_SRC scheme
(/
 (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
 (* 3 ( - 6 2) (- 2 7))
 )
#+END_SRC

The result was ~-37/150~ which matched the solutions I found online.
*** DONE Exercise 1.3
CLOSED: [2017-12-17 Sun 22:29]
#+BEGIN_SRC scheme
(define (square n) (* n n))
(define (sum-of-squares a b) (+ (square a) (square b)))

(define (f a b c)
  (cond
    ((and (> b a) (> c a)) (sum-of-squares b c))
    ((and (> a b) (> c b)) (sum-of-squares a c))
    ((and (> a c) (> b c)) (sum-of-squares a b))
    )
  )
#+END_SRC
*** DONE Exercise 1.4
CLOSED: [2017-12-17 Sun 22:35]
This question asked me to describe the behavior of:

#+BEGIN_SRC scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+END_SRC

The behavior is well described by the name of the function. It calculates ~a~ plus the absolute value of ~b~. This works because if ~b~ is negative (as tested by the if expression in the code) then it will perform an ~a~ minus ~b~ operation, and since ~b~ is already negative the double negative will result in addition.
*** DONE Exercise 1.5
CLOSED: [2017-12-18 Mon 22:08]
If the language is using applicative-order evaluation, the code will enter an infinite loop, because both arguments will be evaluated right away, and the ~p~ function enters and infinite loop. With normal-order evaluation, the code will return ~0~ and will not enter an infinite loop because the value of ~p~ is never needed.
*** DONE Exercise 1.6
CLOSED: [2017-12-19 Tue 22:18]
The program will enter an infinite loop because ~new-if~ does not have the short-circuiting behavior that the regular ~if~ expression does. Every time the ~new-if~ experssion is evaluated, the recursive call to ~sqrt-iter~ will be called and the loop will never end.
*** DONE Exercise 1.7
CLOSED: [2017-12-19 Tue 22:43]
#+BEGIN_SRC scheme
(define (square n) (* n n))

(define (sqrt-iter guess x old-guess)
  (if (good-enough? guess x old-guess)
      guess
      (sqrt-iter (improve guess x) x guess)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x old-guess)
  (< (abs (- guess old-guess)) (* guess 0.001))
  )

(define (sqrt x)
  (sqrt-iter 1.0 x 0.0))

(/ (square (sqrt 1)) 1)
(/ (square (sqrt 2)) 2)
(/ (square (sqrt 10)) 10)
(/ (square (sqrt 0.000001)) 0.000001)
(/ (square (sqrt 10000000000000000000000000000000)) 10000000000000000000000000000000)
#+END_SRC
The above code is modified as requested in the exercise. Before the modification, the code would return a result that was approximately 1000 time too large for the small number case, and would freeze completely on the large number case (there probably wasn't enough precision available to get within the hard coded ~0.001~ tolerance for the large number case).

After the modification all the tests return a reasonably accurate result quickly, even for the small and large number cases.
*** DONE Exercise 1.8
CLOSED: [2017-12-21 Thu 11:00]
#+BEGIN_SRC scheme
(define (square n) (* n n))
(define (cube n) (* n n n))

(define (cube-root-iter guess x old-guess)
  (if (good-enough? guess x old-guess)
      guess
      (cube-root-iter (improve guess x) x guess)))

(define (improve guess x)
  (/
   (+ (/ x (square guess)) (* 2 guess))
   3)
  )

(define (good-enough? guess x old-guess)
  (< (abs (- guess old-guess)) (* guess 0.001))
  )

(define (cube-root x)
  (cube-root-iter 1.0 x 0.0))

(/ (cube (cube-root 1)) 1)
(/ (cube (cube-root 2)) 2)
(/ (cube (cube-root 10)) 10)
(/ (cube (cube-root 0.000001)) 0.000001)
(/ (cube (cube-root 10000000000000000000000000000000)) 10000000000000000000000000000000)
#+END_SRC
I modified the code from exercise 1.7 to calculate the cube root instead of the square root.
*** DONE Exercise 1.9
CLOSED: [2017-12-21 Thu 12:02]
#+BEGIN_SRC scheme
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
#+END_SRC
This question asks about these two procedures: Are the processes described by these procedures iterative or recursive?

The first procedure describes a recursive process. It will build up many ~inc~ operations on the stack.

The second procedure describes a iterative process. The ~dec~ and ~inc~ operations are performed right away, and then the procedure calls itself recursively. There is are no steps left to be performed so the stack is not needed. Also, the variables ~a~ and ~b~ give a complete description of where we are in the iterative process.

Using the substitution model, the two procedures work as follows:
#+BEGIN_EXAMPLE
(+ 4 5)
(inc (+ (dec 4) 5))
(inc (+ 3 5))
(inc (inc (+ (dec 3) 5)))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ (dec 2) 5))))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ (dec 1) 5)))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9
#+END_EXAMPLE
*** TODO Exercise 1.10
*** DONE Exercise 1.11
CLOSED: [2017-12-21 Thu 13:32]
#+BEGIN_SRC scheme
(define (fr n)
  (cond
    ((< n 3) n)
    (else (+ (fr (- n 1)) (* 2 (fr (- n 2))) (* 3 (fr (- n 3)))))
    ))

(fr 0)
(fr 1)
(fr 2)
(fr 3)
(fr 4)
(fr 5)
(fr 6)
(fr 7)

(define (fi n)
  (define (fi-iter a b c n)
    (cond
      ((= n 0) a)
      (else (fi-iter (+ a (* 2 b) (* 3 c)) a b (dec n)))
      ))
  (cond
    ((< n 3) n)
    (else (fi-iter 2 1 0 (- n 2)))
    ))

(fi 0)
(fi 1)
(fi 2)
(fi 3)
(fi 4)
(fi 5)
(fi 6)
(fi 7)
#+END_SRC
*** DONE Exercise 1.12
CLOSED: [2017-12-21 Thu 14:05]
#+BEGIN_SRC scheme
(define (pas n m)
  (cond
    ((<= n 0) 0)
    ((<= m 0) 0)
    ((= m 1) 1)
    ((= n m) 1)
    (else (+ (pas (dec n) (dec m)) (pas (dec n) m)))
    ))
#+END_SRC
*** TODO Exercise 1.13
*** DONE Exercise 1.14
CLOSED: [2017-12-21 Thu 17:50]
#+BEGIN_SRC scheme
(define (coin n)
  (cond
    ((= n 1) 1)
    ((= n 2) 5)
    ((= n 3) 10)
    ((= n 4) 25)
    ((= n 5) 50)
    ))

(define (change n)
  (define (change-iter n c)
    (cond
      ((< n 0) 0)
      ((= n 0) 1)
      ((> c 5) 0)
      (else (+ (change-iter n (inc c)) (change-iter (- n (coin c)) c)))
      )
    )
  (change-iter n 1)
  )
#+END_SRC
I implemented the change function as above.

To explore the process of making change for 11 cents:
#+BEGIN_EXAMPLE scheme
                   (c 11 1)
(+        (c 11 2)             (c 10 1))
(+ (+ (c 11 3) (c 6 2)) (+ (c 10 2) (c 9 1)))
#+END_EXAMPLE
Above is the beginning of a sketch of the recursive process.

The space complexity is ~O(n)~ like most tree recursive processes, only the nodes of the current path need to be kept in memory.

The time complexity is ~O(n^5)~ because there are 5 kinds of coins. Consider:

If we only had 1 kind of coin, it would be straight counting (by the value of that one coin) up to the number of cents we need to make change for. This would be an ~O(n)~ process.
If we had 2 kinds of coins, we would do straight counting by the first coin (~O(n)~), but *for each step* in the counting we would have to count out the remainder from the first coin using the second coin (this counting of the remainder would be ~O(n)~). Combine the two different counts and we get ~O(n^2)~.
Continuing with this logic we eventually get ~O(n^5)~ for the complexity when using all 5 coins.
*** DONE Exercise 1.15
CLOSED: [2017-12-21 Thu 22:25]
#+BEGIN_EXAMPLE
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))
...
#+END_EXAMPLE
~p~ will be called 5 times.

Notice that if we triple the angle we are calling ~sine~ with, it will only add one additional call to ~p~, because we are dividing at every step of the recursive process. This makes it so the order of growth for both time (steps) and space is ~O(log n)~.
*** DONE Exercise 1.16
CLOSED: [2017-12-22 Fri 14:03]
#+BEGIN_SRC scheme
(define (half n) (/ n 2))
(define (square n) (* n n))
(define (even? n) (= (remainder n 2) 0))

(define (exp b n)
  (define (exp-iter a b n)
    (cond
      ((= n 0) a)
      ((even? n) (exp-iter a (square b) (half n)))
      (else (exp-iter (* a b) b (dec n)))
      )
    )
  (exp-iter 1 b n)
  )
#+END_SRC
*** DONE Exercise 1.17
CLOSED: [2017-12-22 Fri 14:18]
#+BEGIN_SRC scheme
(define (half n) (/ n 2))
(define (double n) (* 2 n))
(define (even? n) (= (remainder n 2) 0))

(define (multiply a b)
  (cond
    ((= b 1) a)
    ((even? b) (double (multiply a (half b))))
    (else (+ a (multiply a (dec b))))
    )
  )
#+END_SRC
*** DONE Exercise 1.18
CLOSED: [2017-12-22 Fri 14:54]
#+BEGIN_SRC scheme
(define (half n) (/ n 2))
(define (double n) (* 2 n))
(define (even? n) (= (remainder n 2) 0))

(define (multiply a b)
  (define (multiply-iter a b c)
    (cond
      ((= b 0) c)
      ((even? b) (multiply-iter (double a) (half b) c))
      (else (multiply-iter a (dec b) (+ a c)))
      ))
  (multiply-iter a b 0)
  )
#+END_SRC

Exercise 1.16 says:

#+BEGIN_QUOTE
In general, the technique of defining an invariant quantity
that remains unchanged from state to state is a powerful
way to think about the design of iterative algorithms.
#+END_QUOTE

This exercise is a great example of that.

The invariants here are:

#+BEGIN_EXAMPLE
For the initial case:  ab = ab + c where c = 0
For the even case:     ab + c = 2a * (1/2)b + c
For the odd case:      ab + c = a * (b - 1) + (c + a)
For the terminal case: ab + c = c where b = 0
#+END_EXAMPLE

Notice that both the even and odd cases move us towards our terminal case.
*** TODO Exercise 1.19
*** DONE Exercise 1.20
CLOSED: [2017-12-23 Sat 21:31]
First I will try to evaluate ~(gcd 206 40)~ using the substitution model with normal-order evaluation:

#+BEGIN_EXAMPLE
(gcd 206 40)
(if (= 40 0) 206 (gcd 40 (remainder 206 40)))
(if (= 40 0) 206 (if (= (remainder 206 40) 0) 40 (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))))
...
#+END_EXAMPLE

That is starting to get pretty incomprehensible.

Let's look at the definition of gcd:

#+BEGIN_SRC scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+END_SRC

By looking at the definition, we can see that, under the substitution model with normal-order evaluation:
- ~a~ gets evaluated once in all cases
- ~b~ gets evaluated either 1 or 3 times, depending on the case
- ~remainder~ gets evaluated either 0 or 1 times, depending on the case

Let's look at a simpler case, using the substitution model with applicative-order evaluation:

#+BEGIN_SRC scheme
(gcd 206 40)
(gcd 40 6)
(gcd 6 4)
(gcd 4 2)
(gcd 2 0)
#+END_SRC

~remainder~ would be evaluated at the end of every call, except for the last call with applicative-order evaluation, so it would be called 4 times.

When ~gcd~ receives some arguments, each of those arguments may require calling ~remainder~ zero or more times (under normal-order evaluation). Let ~A~ and ~B~ be the number of times ~remainder~ must be evaluated to get the value of ~a~ and ~b~ repectively.

#+BEGIN_EXAMPLE
f(A,B) = B + A                if B would evaluat to 0
f(A,B) = B + f(B, 1 + A + B)  if B would not evaluate to 0

(gcd 2 0)     (f 0 0)
              (+ 0 0)
              0

(gcd 4 2)     (f 0 0)
(gcd 2 0)     (+ 0 (f 0 1))
              (+ 0 (+ 1 0))
              1

(gcd 6 4)     (f 0 0)
(gcd 4 2)     (+ 0 (f 0 1))
(gcd 2 0)     (+ 0 (+ 1 (f 1 2)))
              (+ 0 (+ 1 (+ 2 1)))
              4

(gcd 40 6)    (f 0 0)
(gcd 6 4)     (+ 0 (f 0 1))
(gcd 4 2)     (+ 0 (+ 1 (f 1 2)))
(gcd 2 0)     (+ 0 (+ 1 (+ 2 (f 2 4))))
              (+ 0 (+ 1 (+ 2 (+ 4 2))))
              9

(gcd 206 40)  (f 0 0)
(gcd 40 6)    (+ 0 (f 0 1))
(gcd 6 4)     (+ 0 (+ 1 (f 1 2)))
(gcd 4 2)     (+ 0 (+ 1 (+ 2 (f 2 4))))
(gcd 2 0)     (+ 0 (+ 1 (+ 2 (+ 4 (f 4 7)))))
              (+ 0 (+ 1 (+ 2 (+ 4 (+ 7 4)))))
              18
#+END_EXAMPLE

18 calls to ~remainder~ are made with normal-order evaluation. Above is some loose notation that demonstrates this.
*** DONE Exercise 1.21
CLOSED: [2017-12-24 Sun 19:23]
#+BEGIN_EXAMPLE
199
1999
7
#+END_EXAMPLE
*** DONE Exercise 1.22
CLOSED: [2017-12-24 Sun 19:55]
**** Code
#+BEGIN_SRC scheme
(define (square n) (* n n))
(define (prime? n)
  (= n (smallest-divisor n)))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))
(define (smallest-divisor n) (find-divisor n 2))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (even? n) (= (remainder n 2) 0))

(define (search-for-primes start n)
  (cond
    ((= n 0) (newline))
    ((even? start) (search-for-primes (inc start) n))
    ((prime? start)
     (timed-prime-test start)
     (search-for-primes (+ 2 start) (dec n)))
    (else (search-for-primes (+ 2 start) n))
    ))
#+END_SRC
**** Timings
#+BEGIN_EXAMPLE
1009 *** 3
1013 *** 3
1019 *** 3

10007 *** 8
10009 *** 9
10037 *** 9

100003 *** 16
100019 *** 16
100043 *** 16

1000003 *** 91
1000033 *** 93
1000037 *** 92
#+END_EXAMPLE
**** Thoughts
As stated in the exercise, each set of timings should be about =sqrt(10)= times longer than the prior set of timings. This appears to be the case, with the exception of the primes above 100,000 which were faster than expected. The timings vary from run to run by a factor of 2 or 3, but it looks like the expected order of growth is within an order of magnitude of the actual times.
*** DONE Exercise 1.23
CLOSED: [2017-12-26 Tue 17:40]
**** Code
#+BEGIN_SRC scheme
(define (square n) (* n n))
(define (prime? n)
  (= n (smallest-divisor n)))
(define (find-divisor n test-divisor)
  (define (next n)
    (cond
      ((even? n) (+ 1 n))
      (else (+ 2 n))
      ))
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))
(define (divides? a b) (= (remainder b a) 0))
(define (smallest-divisor n) (find-divisor n 2))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (even? n) (= (remainder n 2) 0))

(define (search-for-primes start n)
  (cond
    ((= n 0) (newline))
    ((even? start) (search-for-primes (inc start) n))
    ((prime? start)
     (timed-prime-test start)
     (search-for-primes (+ 2 start) (dec n)))
    (else (search-for-primes (+ 2 start) n))
    ))
#+END_SRC
**** Timings
#+BEGIN_EXAMPLE
1009 *** 3
1013 *** 2
1019 *** 3

10007 *** 5
10009 *** 4
10037 *** 4

100003 *** 13
100019 *** 14
100043 *** 31

1000003 *** 40
1000033 *** 33
1000037 *** 33
#+END_EXAMPLE
**** Thoughts
The modified code does appear to be about 2 to 3 times faster.
*** DONE Exercise 1.24
CLOSED: [2017-12-26 Tue 22:23]
**** Code
#+BEGIN_SRC scheme
(define (square n) (* n n))

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(define (prime? n) (fast-prime? n 10))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (even? n) (= (remainder n 2) 0))

(define (search-for-primes start n)
  (cond
    ((= n 0) (newline))
    ((even? start) (search-for-primes (inc start) n))
    ((prime? start)
     (timed-prime-test start)
     (search-for-primes (+ 2 start) (dec n)))
    (else (search-for-primes (+ 2 start) n))
    ))
#+END_SRC
**** Timings
#+BEGIN_EXAMPLE
1009 *** 16
1013 *** 14
1019 *** 15

10007 *** 20
10009 *** 17
10037 *** 16

100003 *** 23
100019 *** 23
100043 *** 23

1000003 *** 25
1000033 *** 26
1000037 *** 26
#+END_EXAMPLE
**** Thoughts
The timings do seem to grow more slowly, and there isn't a lot of difference between the 1,000 and 1,000,000 timings. Identifying the lower primes is slower, but identifying the larger primes is faster.
*** DONE Exercise 1.25
CLOSED: [2017-12-27 Wed 17:16]
**** Observations
#+BEGIN_EXAMPLE
scratch.rkt﻿> (time-expmod expmod 7 13 23)
2331412
scratch.rkt﻿> (time-expmod expmod 7 13 23)
2328239
scratch.rkt﻿> (time-expmod expmod-simple 7 13 23)
1594960
scratch.rkt﻿> (time-expmod expmod-simple 7 13 23)
1606023
scratch.rkt﻿> (time-expmod expmod 22 90 88)
3962562
scratch.rkt﻿> (time-expmod expmod 22 90 88)
3931262
scratch.rkt﻿> (time-expmod expmod-simple 22 90 88)
11879365
scratch.rkt﻿> (time-expmod expmod-simple 22 90 88)
11755261
scratch.rkt﻿> (time-expmod expmod 22 900 88)
5574822
scratch.rkt﻿> (time-expmod expmod 22 900 88)
5629995
scratch.rkt﻿> (time-expmod expmod-simple 22 900 88)
49971999
scratch.rkt﻿> (time-expmod expmod-simple 22 900 88)
49957669
#+END_EXAMPLE
**** Code
#+BEGIN_SRC scheme
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))

(define (square n) (* n n))

(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))

(define (expmod-simple base exp m)
  (remainder (fast-expt base exp) m))

(define (time-expmod f base exp m)
  (define (iter starttime n)
    (cond ((= n 0) (- (runtime) starttime))
          (else (f base exp m)
                (iter starttime (dec n))
                )))
  (iter (runtime) 10000000)
  )
#+END_SRC
**** Thoughts
My experiments show that ~expmod-simple~ (the simplified version of expmod in the exercise), takes much longer than the ~expmod~ from the chapter body on large inputs. It is faster on small inputs though.

The ~expmod-simple~ from the exercise performs many ~square~ operations and multiplication operations, and then ends with a single large ~remainder~ operation. This is different than the ~expmod~ from the chapter body, which interleaves many ~square~ / multiplication and ~remainder~ operations.

~expmod-simple~ ends up having to deal with some very very large numbers which make it slower apparently.

~expmod-simple~ calls ~remainder~ once with the following numbers:
#+BEGIN_EXAMPLE
151500037377440640765229965084862736481581201922403009524250816922368622529367267027151087462523849447461906980964644550129657960687694718939297936666538128651960731935302110984828778132466682335112987387911997848629563807304450268134917832594194031630315031523409866449672617615786253286603966041083426292450512374377896054869843711536355968891778761825480306707789616654689214630068689277863118510091668006980517876353870920803653327621921444904027134903294882867410743407464472554946546783476239955399312887285457092199959393189799243468658041263344680252035489792480140875249951754534714778456655359834675286983520966582034298451518792492678678095263577945370763475628949330154201348352674902544471591682198464236226566496046544424222792823042528586344687484008953057210897097500052627047823165352259782519165081327753839338652676817942340253626461332329630152662369952603239777468201600892286524084745474556467233589494398978583209136937319895500686411945200314288069444841998777011740413076051006123196967060249185789370233405845397687048673462976997664593740250697156263025697826859658380533521298642977549849690397539907154280210689945080813748743555671339252011653961301105724368600939727513899237376 880
#+END_EXAMPLE

~expmod~ calls ~remainder~ several times with smaller numbers:
#+BEGIN_EXAMPLE
22 88
484 88
968 88
0 88
0 88
0 88
0 88
0 88
0 88
0 88
0 88
0 88
0 88
#+END_EXAMPLE

It's not obvious to me that a single call with a large number should be much slower than multiple calls with smaller numbers. I guess this is why it's important to time operations, especially when not familiar with the implementation.
*** DONE Exercise 1.26
CLOSED: [2017-12-26 Tue 22:36]
Consider two expressions:

#+BEGIN_SRC scheme
(define (square n) (* n n))

(square (f 5))
(* (f 5) (f 5))
#+END_SRC

The second expression calculated ~(f 5)~ twice. The first expression calculates ~(f 5)~ once and then uses the resulting value twice, rather than calculating ~(f 5)~ twice, and using each of the resulting values (which are equal) once each.

As for ~expmod~: It goes from a ~O(log n)~ process to a ~O(n)~ process because calling ~expmod~ twice per each iteration, like the code in the exercise, results in a ~O(2^n)~ growth. However, at each step it is halving the input (which is where the ~log~ came from in the order of growth for the correct algorithm) so we end up with ~O(log n)~ combined with ~O(2^n)~ and these combine to ~O(n)~.
*** DONE Exercise 1.27
CLOSED: [2017-12-27 Wed 17:43]
**** Code
#+BEGIN_SRC scheme
(define (fermat-test n)
  (define (passes-fermat-test a)
    (cond
      ((= a 0) true)
      ((= (expmod a n n) a) (passes-fermat-test (dec a)))
      (else false)
      ))
  (passes-fermat-test (dec n))
  )

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))

(define (square n) (* n n))
#+END_SRC
**** Testing
#+BEGIN_EXAMPLE
scratch.rkt﻿> (fermat-test 1)
#t
scratch.rkt﻿> (fermat-test 2)
#t
scratch.rkt﻿> (fermat-test 3)
#t
scratch.rkt﻿> (fermat-test 4)
#f
scratch.rkt﻿> (fermat-test 5)
#t
scratch.rkt﻿> (fermat-test 6)
#f
scratch.rkt﻿> (fermat-test 1104)
#f
scratch.rkt﻿> (fermat-test 1105)
#t
#+END_EXAMPLE
**** Thoughts
This code shows that, for the primes tested, every ~a < n~ does pass the Fermat test. It also show that numbers like ~1105~, which is obviously not prime, also pases the Fermat test for all ~a < n~.

This demonstrates the existence of Carmichael numbers as requested in the exercise.
*** DONE Exercise 1.28
CLOSED: [2017-12-27 Wed 23:14]
**** Code
#+BEGIN_SRC scheme
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((miller-rabin n) (fast-prime? n (- times 1)))
        (else false)))

(define (miller-rabin n)
  (define a (+ 1 (random (- n 1))))
  (= (expmod a (dec n) n) 1)
  )

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))

(define (square n) (* n n))
#+END_SRC
**** Thoughts
I tested the modified version of ~fast-prime?~ and couldn't find any case in which it failed. It correctly identified all of the Carmichael numbers as non-prime.

I did modify ~expmod~ as asked in the exercise. It called ~expmod~ recursively twice at each step of the recursion, which is inefficient, but it worked. The whole part about modifying ~expmod~ was confusing; I think it only asked for the modification to facilitate a mathematical proof, but everything seems to work even without the modification. My modification to ~expmod~ was inspired by a solution I found online.
**** Modified ~expmod~
#+BEGIN_SRC scheme
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((miller-rabin n) (fast-prime? n (- times 1)))
        (else false)))

(define (miller-rabin n)
  (define a (+ 1 (random (- n 1))))
  (= (expmod a (dec n) n) 1)
  )

(define (non-trivial-sqrt? n m)
  (cond ((= n 1) false)
        ((= n (- m 1)) false)
        (else (= (remainder (square n) m) 1))
        ))

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (if (non-trivial-sqrt? (expmod base (/ exp 2) m) m) 0 (remainder (square (expmod base (/ exp 2) m)) m))
         )
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))

(define (square n) (* n n))
#+END_SRC
**** Further Improvements
#+BEGIN_SRC scheme
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((miller-rabin n) (fast-prime? n (- times 1)))
        (else false)))

(define (miller-rabin n)
  (define a (+ 1 (random (- n 1))))
  (= (expmod a (dec n) n) 1)
  )

(define (non-trivial-sqrt? n m)
  (cond ((= n 1) false)
        ((= n (- m 1)) false)
        (else (= (remainder (square n) m) 1))
        ))

(define (check-non-trivial-sqrt n m)
  (if (non-trivial-sqrt? n m) 0 (remainder (square n) m))
  )

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp) (check-non-trivial-sqrt (expmod base (/ exp 2) m) m))
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))

(define (square n) (* n n))
#+END_SRC

#+BEGIN_EXAMPLE
scratch.rkt﻿> (fast-prime? 561 100)
#f
scratch.rkt﻿> (fast-prime? 1105 100)
#f
scratch.rkt﻿> (fast-prime? 2821 100)
#f
scratch.rkt﻿> (fast-prime? 7043 100)
#t
scratch.rkt﻿> (fast-prime? 7047 100)
#f
scratch.rkt﻿> (fast-prime? 7057 100)
#t
#+END_EXAMPLE

I made the above improvement to avoid calculating ~expmod~ twice each iteration. It seems to work, and it not fooled by the Carmichael numbers.
*** DONE Exercise 1.29
CLOSED: [2017-12-29 Fri 16:15]
**** Code
#+BEGIN_SRC scheme
(define (cube n) (* n n n))

(define (even? n) (= (remainder n 2) 0))

(define (simpson f a b n)
  (define h (/ (- b a) n))
  (define (y k) (f (+ a (* k h))))
  (define (y-index-factor y-index)
    (cond ((= y-index 0) 1)
          ((= y-index n) 1)
          ((even? y-index) 2)
          (else 4)
          ))
  (define (simpson-sum y-index sum)
    (cond ((> y-index n) sum)
          (else (simpson-sum (inc y-index) (+ sum (* (y-index-factor y-index) (y y-index)))))
          ))
  (* (/ h 3) (simpson-sum 0 0))
  )
#+END_SRC
**** Demo
#+BEGIN_EXAMPLE
scratch.rkt﻿> (simpson cube 0.0 1.0 100)
0.25000000000000006
scratch.rkt﻿> (simpson cube 0.0 1.0 1000)
0.25000000000000006
#+END_EXAMPLE
**** Thoughts
The code appears to work. It does not appear to get any more or less accurate when increasing ~n~, at least not for the integral of ~cube~ from 0 to 1.

It is more accurate than the ~integral~ procedure defined on page 79.
*** DONE Exercise 1.30
CLOSED: [2018-01-01 Mon 11:21]
#+BEGIN_SRC scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))
#+END_SRC
*** DONE Exercise 1.31
CLOSED: [2018-01-01 Mon 15:59]
#+BEGIN_SRC scheme
(define (id a) a)

(define (product-iter term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))

(define (product-recursive term a next b)
  (if (> a b)
      1
      (* (term a)
         (product-recursive term (next a) next b))))

(define (factorial n)
  (product-recursive id 1 inc n))

(define (add-2 n) (+ 2 n))
(define (pi-approx-term n)
  (* (/ n (+ 1 n)) (/ (+ 2 n) (+ 1 n))))
(* 4 (product-iter pi-approx-term 2.0 add-2 2.0))
(* 4 (product-iter pi-approx-term 2.0 add-2 20.0))
(* 4 (product-iter pi-approx-term 2.0 add-2 2000.0))
#+END_SRC
*** DONE Exercise 1.32
CLOSED: [2018-01-01 Mon 16:53]
#+BEGIN_SRC scheme
(define (id a) a)

(define (accumulate-iter combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (combiner (term a) result))))
  (iter a null-value))

(define (accumulate-recursive combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate-recursive combiner null-value term (next a) next b))))

(define (add-2 n) (+ 2 n))
(define (pi-approx-term n)
  (* (/ n (+ 1 n)) (/ (+ 2 n) (+ 1 n))))
(* 4 (accumulate-iter * 1 pi-approx-term 2.0 add-2 2.0))
(* 4 (accumulate-iter * 1 pi-approx-term 2.0 add-2 20.0))
(* 4 (accumulate-iter * 1 pi-approx-term 2.0 add-2 2000.0))
(accumulate-recursive + 0 id 1 inc 10)
#+END_SRC
*** DONE Exercise 1.33
CLOSED: [2018-01-01 Mon 17:34]
**** Code
#+BEGIN_SRC scheme
(define (id a) a)

(define (square n) (* n n))

(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

(define (prime? n)
  (= n (smallest-divisor n)))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))
(define (smallest-divisor n) (find-divisor n 2))

(define (filter-accumulate combiner null-value term a next b filter)
  (define (iter a result) (iter-w-term a result (term a)))
  (define (iter-w-term a result evaled-term)
    (cond ((> a b) result)
          ((filter evaled-term) (iter (next a) (combiner evaled-term result)))
          (else (iter (next a) result))
          ))
  (iter a null-value))

(define (sum-of-squares-of-primes a b)
  (define (f a) (prime? (sqrt a)))
  (filter-accumulate + 0 square a inc b f)
  )

(define (product-of-relatively-prime n)
  (define (relatively-prime? i) (= 1 (gcd i n)))
  (filter-accumulate * 1 id 1 inc n relatively-prime?)
  )

(sum-of-squares-of-primes 0 10)
(product-of-relatively-prime 10)
#+END_SRC
**** Thoughts
I find it interesting how I avoided calculating ~(term a)~ twice in ~filter-accumulate~. There is ~iter~ and ~iter-w-term~, ~iter~ is just a wrapper around ~iter-w-term~ to evaluate ~(term a)~ before calling ~iter-w-term~. ~iter-w-term~ then uses the calculated value of ~(term a)~ twice. This should still be an iterative process (it can be tail-call-optimized), since there are no operations left to be done on the stack whenever ~iter~ or ~iter-w-term~ are called.
*** DONE Exercise 1.34
CLOSED: [2018-01-01 Mon 22:32]
The question is, if we have ~(define (f g) (g 2))~ then what will the result of ~(f f)~ be?

I think this will result in a runtime error, it will eventually try to evaluate ~(2 2)~ and ~2~ is not an operator.

I tried and got the following runtime error:

#+BEGIN_EXAMPLE
; application: not a procedure;
;  expected a procedure that can be applied to arguments
;   given: 2
;   arguments...:
;    2
; Context:
;  /.../scratch.rkt:1:1 [running body]
; [Due to errors, REPL is just racket/base]
#+END_EXAMPLE
*** DONE Exercise 1.35
CLOSED: [2018-01-02 Tue 23:07]
From section 1.2.2 we learn that ~p^2 = p + 1~ when ~p~ is the golden ratio (approximately 1.618034). If you divide both sides of that equation by ~p~, you get ~p = 1 + (1 / p)~ which is what this exercise asks us to show.

#+BEGIN_SRC scheme
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.5)
#+END_SRC

The output is: ~1.6180327868852458~
*** DONE Exercise 1.36
CLOSED: [2018-01-03 Wed 21:46]
**** Without average damping
#+BEGIN_SRC scheme
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point (lambda (x) (/ (log 1000) (log x))) 2)
#+END_SRC
#+BEGIN_EXAMPLE
2
9.965784284662087
3.004472209841214
6.279195757507157
3.759850702401539
5.215843784925895
4.182207192401397
4.8277650983445906
4.387593384662677
4.671250085763899
4.481403616895052
4.6053657460929
4.5230849678718865
4.577114682047341
4.541382480151454
4.564903245230833
4.549372679303342
4.559606491913287
4.552853875788271
4.557305529748263
4.554369064436181
4.556305311532999
4.555028263573554
4.555870396702851
4.555315001192079
4.5556812635433275
4.555439715736846
4.555599009998291
4.555493957531389
4.555563237292884
4.555517548417651
4.555547679306398
4.555527808516254
4.555540912917957
4.555532270803653
#+END_EXAMPLE
**** With average damping
#+BEGIN_SRC scheme
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point (lambda (x) (/ (+ (/ (log 1000) (log x)) x) 2)) 2)
#+END_SRC
#+BEGIN_EXAMPLE
2
5.9828921423310435
4.922168721308343
4.628224318195455
4.568346513136242
4.5577305909237005
4.555909809045131
4.555599411610624
4.5555465521473675
4.555537551999825
#+END_EXAMPLE
**** Thoughts
It's cool how the algorithm can be improved by only adjusting the form of the input lambda function.

To perform average damping, add ~x~ (or whatever lambda term you happen to be using) to both sides of an equation, and then divide by 2.
*** DONE Exercise 1.37
CLOSED: [2018-01-04 Thu 23:26]
#+BEGIN_EXAMPLE
scratch.rkt﻿> (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 4)
0.6000000000000001
scratch.rkt﻿> (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 5)
0.625
scratch.rkt﻿> (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 6)
0.6153846153846154
scratch.rkt﻿> (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 7)
0.6190476190476191
scratch.rkt﻿> (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 8)
0.6176470588235294
scratch.rkt﻿> (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 9)
0.6181818181818182
scratch.rkt﻿> (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 10)
0.6179775280898876
scratch.rkt﻿> (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 11)
0.6180555555555556
scratch.rkt﻿> (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 12)
0.6180257510729613
#+END_EXAMPLE

In this exercise, the ~k~ value must be 12 or more to get 4 decimal places of accuracy.

I implemented this algorithm both recursively and iteratively as requested in the exercise.

It's interesting how you have to go backwards through the indices to for the iterative process. I don't know if you must do it that way, but that was the only way I could see.

#+BEGIN_SRC scheme
(define (cont-frac n d k)
  (define (iter l)
    (cond ((> l k) 0)
          (else (/
                 (n l)
                 (+ (d l) (iter (inc l)))))))
  (iter 1)
  )

(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           99)

(define (cont-frac-iterative n d k)
  (define (iter l result)
    (cond ((= l 0) result)
          (else (iter
                 (dec l)
                 (/ (n l)
                    (+ (d l) result))))
          ))
  (iter k 0)
  )

(cont-frac-iterative (lambda (i) 1.0)
                     (lambda (i) 1.0)
                     99)
#+END_SRC
*** DONE Exercise 1.38
CLOSED: [2018-01-04 Thu 23:43]
#+BEGIN_SRC scheme
(define (cont-frac n d k)
  (define (iter l)
    (cond ((> l k) 0)
          (else (/
                 (n l)
                 (+ (d l) (iter (inc l)))))))
  (iter 1)
  )

(define (cont-frac-iterative n d k)
  (define (iter l result)
    (cond ((= l 0) result)
          (else (iter
                 (dec l)
                 (/ (n l)
                    (+ (d l) result))))
          ))
  (iter k 0)
  )

(define (d i)
  (let ((i (+ i 1)))
        (cond ((= (remainder i 3) 0) (* 2 (/ i 3)))
              (else 1)
              )
        ))

(+ 2 (cont-frac (lambda (i) 1.0) d 10))
(+ 2 (cont-frac (lambda (i) 1.0) d 10000))
(+ 2 (cont-frac-iterative (lambda (i) 1.0) d 10))
(+ 2 (cont-frac-iterative (lambda (i) 1.0) d 10000))
#+END_SRC

I used the procedures I created in exercise 1.37. The ~d~ function was a little tricky to come up with.
*** TODO Exercise 1.39
*** TODO Exercise 1.40
*** TODO Exercise 1.41
*** TODO Exercise 1.42
*** TODO Exercise 1.43
*** TODO Exercise 1.44
*** TODO Exercise 1.45
*** TODO Exercise 1.46
** Chapter 2 [0/97] [0%]
*** TODO Exercise 2.1
*** TODO Exercise 2.2
*** TODO Exercise 2.3
*** TODO Exercise 2.4
*** TODO Exercise 2.5
*** TODO Exercise 2.6
*** TODO Exercise 2.7
*** TODO Exercise 2.8
*** TODO Exercise 2.9
*** TODO Exercise 2.10
*** TODO Exercise 2.11
*** TODO Exercise 2.12
*** TODO Exercise 2.13
*** TODO Exercise 2.14
*** TODO Exercise 2.15
*** TODO Exercise 2.16
*** TODO Exercise 2.17
*** TODO Exercise 2.18
*** TODO Exercise 2.19
*** TODO Exercise 2.20
*** TODO Exercise 2.21
*** TODO Exercise 2.22
*** TODO Exercise 2.23
*** TODO Exercise 2.24
*** TODO Exercise 2.25
*** TODO Exercise 2.26
*** TODO Exercise 2.27
*** TODO Exercise 2.28
*** TODO Exercise 2.29
*** TODO Exercise 2.30
*** TODO Exercise 2.31
*** TODO Exercise 2.32
*** TODO Exercise 2.33
*** TODO Exercise 2.34
*** TODO Exercise 2.35
*** TODO Exercise 2.36
*** TODO Exercise 2.37
*** TODO Exercise 2.38
*** TODO Exercise 2.39
*** TODO Exercise 2.40
*** TODO Exercise 2.41
*** TODO Exercise 2.42
*** TODO Exercise 2.43
*** TODO Exercise 2.44
*** TODO Exercise 2.45
*** TODO Exercise 2.46
*** TODO Exercise 2.47
*** TODO Exercise 2.48
*** TODO Exercise 2.49
*** TODO Exercise 2.50
*** TODO Exercise 2.51
*** TODO Exercise 2.52
*** TODO Exercise 2.53
*** TODO Exercise 2.54
*** TODO Exercise 2.55
*** TODO Exercise 2.56
*** TODO Exercise 2.57
*** TODO Exercise 2.58
*** TODO Exercise 2.59
*** TODO Exercise 2.60
*** TODO Exercise 2.61
*** TODO Exercise 2.62
*** TODO Exercise 2.63
*** TODO Exercise 2.64
*** TODO Exercise 2.65
*** TODO Exercise 2.66
*** TODO Exercise 2.67
*** TODO Exercise 2.68
*** TODO Exercise 2.69
*** TODO Exercise 2.70
*** TODO Exercise 2.71
*** TODO Exercise 2.72
*** TODO Exercise 2.73
*** TODO Exercise 2.74
*** TODO Exercise 2.75
*** TODO Exercise 2.76
*** TODO Exercise 2.77
*** TODO Exercise 2.78
*** TODO Exercise 2.79
*** TODO Exercise 2.80
*** TODO Exercise 2.81
*** TODO Exercise 2.82
*** TODO Exercise 2.83
*** TODO Exercise 2.84
*** TODO Exercise 2.85
*** TODO Exercise 2.86
*** TODO Exercise 2.87
*** TODO Exercise 2.88
*** TODO Exercise 2.89
*** TODO Exercise 2.90
*** TODO Exercise 2.91
*** TODO Exercise 2.92
*** TODO Exercise 2.93
*** TODO Exercise 2.94
*** TODO Exercise 2.95
*** TODO Exercise 2.96
*** TODO Exercise 2.97
** Chapter 3 [0/82] [0%]
*** TODO Exercise 3.1
*** TODO Exercise 3.2
*** TODO Exercise 3.3
*** TODO Exercise 3.4
*** TODO Exercise 3.5
*** TODO Exercise 3.6
*** TODO Exercise 3.7
*** TODO Exercise 3.8
*** TODO Exercise 3.9
*** TODO Exercise 3.10
*** TODO Exercise 3.11
*** TODO Exercise 3.12
*** TODO Exercise 3.13
*** TODO Exercise 3.14
*** TODO Exercise 3.15
*** TODO Exercise 3.16
*** TODO Exercise 3.17
*** TODO Exercise 3.18
*** TODO Exercise 3.19
*** TODO Exercise 3.20
*** TODO Exercise 3.21
*** TODO Exercise 3.22
*** TODO Exercise 3.23
*** TODO Exercise 3.24
*** TODO Exercise 3.25
*** TODO Exercise 3.26
*** TODO Exercise 3.27
*** TODO Exercise 3.28
*** TODO Exercise 3.29
*** TODO Exercise 3.30
*** TODO Exercise 3.31
*** TODO Exercise 3.32
*** TODO Exercise 3.33
*** TODO Exercise 3.34
*** TODO Exercise 3.35
*** TODO Exercise 3.36
*** TODO Exercise 3.37
*** TODO Exercise 3.38
*** TODO Exercise 3.39
*** TODO Exercise 3.40
*** TODO Exercise 3.41
*** TODO Exercise 3.42
*** TODO Exercise 3.43
*** TODO Exercise 3.44
*** TODO Exercise 3.45
*** TODO Exercise 3.46
*** TODO Exercise 3.47
*** TODO Exercise 3.48
*** TODO Exercise 3.49
*** TODO Exercise 3.50
*** TODO Exercise 3.51
*** TODO Exercise 3.52
*** TODO Exercise 3.53
*** TODO Exercise 3.54
*** TODO Exercise 3.55
*** TODO Exercise 3.56
*** TODO Exercise 3.57
*** TODO Exercise 3.58
*** TODO Exercise 3.59
*** TODO Exercise 3.60
*** TODO Exercise 3.61
*** TODO Exercise 3.62
*** TODO Exercise 3.63
*** TODO Exercise 3.64
*** TODO Exercise 3.65
*** TODO Exercise 3.66
*** TODO Exercise 3.67
*** TODO Exercise 3.68
*** TODO Exercise 3.69
*** TODO Exercise 3.70
*** TODO Exercise 3.71
*** TODO Exercise 3.72
*** TODO Exercise 3.73
*** TODO Exercise 3.74
*** TODO Exercise 3.75
*** TODO Exercise 3.76
*** TODO Exercise 3.77
*** TODO Exercise 3.78
*** TODO Exercise 3.79
*** TODO Exercise 3.80
*** TODO Exercise 3.81
*** TODO Exercise 3.82
** Chapter 4 [0/79] [0%]
*** TODO Exercise 4.1
*** TODO Exercise 4.2
*** TODO Exercise 4.3
*** TODO Exercise 4.4
*** TODO Exercise 4.5
*** TODO Exercise 4.6
*** TODO Exercise 4.7
*** TODO Exercise 4.8
*** TODO Exercise 4.9
*** TODO Exercise 4.10
*** TODO Exercise 4.11
*** TODO Exercise 4.12
*** TODO Exercise 4.13
*** TODO Exercise 4.14
*** TODO Exercise 4.15
*** TODO Exercise 4.16
*** TODO Exercise 4.17
*** TODO Exercise 4.18
*** TODO Exercise 4.19
*** TODO Exercise 4.20
*** TODO Exercise 4.21
*** TODO Exercise 4.22
*** TODO Exercise 4.23
*** TODO Exercise 4.24
*** TODO Exercise 4.25
*** TODO Exercise 4.26
*** TODO Exercise 4.27
*** TODO Exercise 4.28
*** TODO Exercise 4.29
*** TODO Exercise 4.30
*** TODO Exercise 4.31
*** TODO Exercise 4.32
*** TODO Exercise 4.33
*** TODO Exercise 4.34
*** TODO Exercise 4.35
*** TODO Exercise 4.36
*** TODO Exercise 4.37
*** TODO Exercise 4.38
*** TODO Exercise 4.39
*** TODO Exercise 4.40
*** TODO Exercise 4.41
*** TODO Exercise 4.42
*** TODO Exercise 4.43
*** TODO Exercise 4.44
*** TODO Exercise 4.45
*** TODO Exercise 4.46
*** TODO Exercise 4.47
*** TODO Exercise 4.48
*** TODO Exercise 4.49
*** TODO Exercise 4.50
*** TODO Exercise 4.51
*** TODO Exercise 4.52
*** TODO Exercise 4.53
*** TODO Exercise 4.54
*** TODO Exercise 4.55
*** TODO Exercise 4.56
*** TODO Exercise 4.57
*** TODO Exercise 4.58
*** TODO Exercise 4.59
*** TODO Exercise 4.60
*** TODO Exercise 4.61
*** TODO Exercise 4.62
*** TODO Exercise 4.63
*** TODO Exercise 4.64
*** TODO Exercise 4.65
*** TODO Exercise 4.66
*** TODO Exercise 4.67
*** TODO Exercise 4.68
*** TODO Exercise 4.69
*** TODO Exercise 4.70
*** TODO Exercise 4.71
*** TODO Exercise 4.72
*** TODO Exercise 4.73
*** TODO Exercise 4.74
*** TODO Exercise 4.75
*** TODO Exercise 4.76
*** TODO Exercise 4.77
*** TODO Exercise 4.78
*** TODO Exercise 4.79
** Chapter 5 [0/52] [0%]
*** TODO Exercise 5.1
*** TODO Exercise 5.2
*** TODO Exercise 5.3
*** TODO Exercise 5.4
*** TODO Exercise 5.5
*** TODO Exercise 5.6
*** TODO Exercise 5.7
*** TODO Exercise 5.8
*** TODO Exercise 5.9
*** TODO Exercise 5.10
*** TODO Exercise 5.11
*** TODO Exercise 5.12
*** TODO Exercise 5.13
*** TODO Exercise 5.14
*** TODO Exercise 5.15
*** TODO Exercise 5.16
*** TODO Exercise 5.17
*** TODO Exercise 5.18
*** TODO Exercise 5.19
*** TODO Exercise 5.20
*** TODO Exercise 5.21
*** TODO Exercise 5.22
*** TODO Exercise 5.23
*** TODO Exercise 5.24
*** TODO Exercise 5.25
*** TODO Exercise 5.26
*** TODO Exercise 5.27
*** TODO Exercise 5.28
*** TODO Exercise 5.29
*** TODO Exercise 5.30
*** TODO Exercise 5.31
*** TODO Exercise 5.32
*** TODO Exercise 5.33
*** TODO Exercise 5.34
*** TODO Exercise 5.35
*** TODO Exercise 5.36
*** TODO Exercise 5.37
*** TODO Exercise 5.38
*** TODO Exercise 5.39
*** TODO Exercise 5.40
*** TODO Exercise 5.41
*** TODO Exercise 5.42
*** TODO Exercise 5.43
*** TODO Exercise 5.44
*** TODO Exercise 5.45
*** TODO Exercise 5.46
*** TODO Exercise 5.47
*** TODO Exercise 5.48
*** TODO Exercise 5.49
*** TODO Exercise 5.50
*** TODO Exercise 5.51
*** TODO Exercise 5.52
